1.定义:

通过电灯的例子，相信我们对于状态模式已经有了一定程度的了解。现在回头来看 GoF 中
对状态模式的定义：
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
我们以逗号分割，把这句话分为两部分来看。第一部分的意思是将状态封装成独立的类，并
将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子
足以说明这一点，在 off 和 on 这两种不同的状态下，我们点击同一个按钮，得到的行为反馈是截
然不同的。
第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这
个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。


2.状态模式的优缺点

  到这里我们已经学习了两个状态模式的例子，现在是时候来总结状态模式的优缺点了。状态
  模式的优点如下。
    状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态
  类，很容易增加新的状态和转换。
    避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过
  多的条件分支。
    用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。
    Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。
  状态模式的缺点是会在系统中定义许多状态类，编写 20 个状态类是一项枯燥乏味的工作，
  而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条
  件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。
3.状态模式中的性能优化点

  在这两个例子中，我们并没有太多地从性能方面考虑问题，实际上，这里有一些比较大的优
  化点。
    有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并
  随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果 state
  对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象
  并及时地回收它们。但如果状态的改变很频繁，最好一开始就把这些 state 对象都创建出
  来，也没有必要销毁它们，因为可能很快将再次用到它们。
    在本章的例子中，我们为每个 Context 对象都创建了一组 state 对象，实际上这些 state
  对象之间是可以共享的，各 Context 对象可以共享一个 state 对象，这也是享元模式的应
  用场景之一。

4.状态模式和策略模式的关系

策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请
求委托给这些类来执行。

它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，
所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态
和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情
发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。